<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.2) on Wed Jun 19 19:02:10 EEST 2019 -->
<title>Constant Field Values (tp5)</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="dc.created" content="2019-06-19">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Constant Field Values (tp5)";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "./";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="index.html">Overview</a></li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<main role="main">
<div class="header">
<h1 title="Constant Field Values" class="title">Constant Field Values</h1>
<section role="region">
<h2 title="Contents">Contents</h2>
<ul>
<li><a href="#question2">question2.*</a></li>
</ul>
</section>
</div>
<div class="constantValuesContainer"><a id="question2">
<!--   -->
</a>
<section role="region">
<h2 title="question2">question2.*</h2>
<ul class="blockList">
<li class="blockList">
<table class="constantsSummary">
<caption><span>question2.<a href="question2/Chapitre2CoreJava2.html" title="class in question2">Chapitre2CoreJava2</a></span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Constant Field</th>
<th class="colLast" scope="col">Value</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a id="question2.Chapitre2CoreJava2.CHAPITRE2">
<!--   -->
</a><code>public&nbsp;static&nbsp;final&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><a href="question2/Chapitre2CoreJava2.html#CHAPITRE2">CHAPITRE2</a></code></th>
<td class="colLast"><code>"Core Java 2, Volume II\n\nby Cay S. Horstmann and Gary Cornell\nChapter 2: Collections\n\nConcrete Collections\nRather than getting into more details about all the interfaces, we thought it would be helpful to first discuss the\nconcrete data structures that the Java library supplies. Once you have a thorough understanding of what classes you\nwill want to use, we will return to abstract considerations and see how the collections framework organizes these\nclasses. \nLinked Lists \nWe used arrays and their dynamic cousin, the Vector class, for many examples in Volume 1. However, arrays and\nvectors suffer from a major drawback. Removing an element from the middle of an array is very expensive since all\narray elements beyond the removed one must be moved toward the beginning of the array (see Figure 2-4). The\nsame is true for inserting elements in the middle. \n                                                          \nFigure 2-4: Removing an element from an array \nAnother well-known data structure, the linked list, solves this problem. Whereas an array stores object references in\nconsecutive memory locations, a linked list stores each object in a separate link. Each link also stores a reference to\nthe next link in the sequence. In the Java programming language, all linked lists are actually doubly linked, that is, each\nlink also stores a reference to its predecessor (see Figure 2-5). \n                                                          \nFigure 2-5: A doubly linked list \nRemoving an element from the middle of a linked list is an inexpensive operation--only the links around the element\nto be removed need to be updated (see Figure 2-6). \n                                                          \nFigure 2-6: Removing an element from a linked list \nPerhaps you once had a course in data structures where you learned how to implement linked lists. You may have\nbad memories of tangling up the links when removing or adding elements in the linked list. If so, you will be pleased to\nlearn that the Java collections library supplies a class LinkedList ready for you to use. \nThe LinkedList class implements the Collection interface. You can use the familiar methods to traverse a list. The\nfollowing code example prints the first three elements of a list, adds three elements, and then removes the third one. \nLinkedList staff = \n     new LinkedList();\nstaff.add(\"Angela\");\nstaff.add(\"Bob\");\nstaff.add(\"Carl\");\nIterator iter = staff.iterator();\nfor (int i = 0; i &lt; 3; i++)\n   System.out.println(iter.next());\niter.remove(); // remove last \n//visited element\nHowever, there is an important difference between linked lists and generic collections. A linked list is an ordered\ncollection where the position of the objects matters. The LinkedList.add method adds the object to the end of the\nlist. But you often want to add objects somewhere in the middle of a list. This position-dependent add method is the\nresponsibility of an iterator, since iterators describe positions in collections. Using iterators to add elements only\nmakes sense for collections that have a natural ordering. For example, the set data type that we discuss in the next\nsection does not impose any ordering on its elements. Therefore, there is no add method in the Iterator interface.\nInstead, the collections library supplies a subinterface ListIterator that contains an add method: \ninterface ListIterator \n        extends Iterator\n{  void add(Object);\n   . . .\n}\nUnlike Collection.add, this method does not return a boolean--it is assumed that the add operation always succeeds. \nIn addition, the ListIterator interface has two methods: \nObject previous()\nboolean hasPrevious()\n--that you can use for traversing a list backwards. Like the next method, the previous method returns the object that\nit skipped over. \nThe listIterator method of the LinkedList class returns an iterator object that implements the ListIterator\ninterface. \nListIterator iter = \n         staff.listIterator();\nThe add method adds the new element before the iterator position. For example, the code \nListIterator iter = \n       staff.listIterator();\niter.next();\niter.add(\"Juliet\");\nskips past the first element in the linked list and adds \"Juliet\" before the second element (see Figure 2-7). \n                                                          \nFigure 2-7: Adding an element to a linked list \nIf you call the add method multiple times, the elements are simply added in the order in which you supplied them.\nThey all get added in turn before the current iterator position. \nWhen you use the add operation with an iterator that was freshly returned from the listIterator method and that\npoints to the beginning of the linked list, the newly added element becomes the new head of the list. When the\niterator has passed the last element of the list (that is, when hasNext returns false), the added element becomes the\nnew tail of the list. If the linked list has n elements, there are n + 1 spots for adding a new element. These spots\ncorrespond to the n + 1 possible positions of the iterator. For example, if a linked list contains three elements A, B,\nand C, then the four possible positions (marked as |) for inserting a new element are: \n|ABC\nA|BC\nAB|C\nABC|\nNOTE: You have to be careful with the \"cursor\" analogy. The remove operation does not quite work like the\nBACKSPACE key. Immediately after a call to next, the remove method indeed removes the element to the left of the\niterator, just like the backspace key would. However, if you just called previous, the element to the right is removed.\nAnd you can\'t call remove twice in a row. \nUnlike the add method, which only depends on the iterator position, the remove method depends on the iterator state.\nFinally, there is a set method that replaces the last element returned by a call to next or previous with a new\nelement. For example, the following code replaces the first element of a list with a new value: \nListIterator iter = list.listIterator();\nObject oldValue = iter.next(); // returns first element\niter.set(newValue); // sets first element to newValue\nAs you might imagine, if an iterator traverses a collection while another iterator is modifying it, confusing situations\ncan occur. For example, suppose an iterator points before an element that another iterator has just removed. The\niterator is now invalid and should no longer be used. The linked list iterators have been designed to detect such\nmodifications. If an iterator finds that its collection has been modified by another iterator or by a method of the\ncollection itself, then it throws a ConcurrentModificationException. For example, consider the following code: \nLinkedList list = . . .;\nListIterator iter1 = \n        list.listIterator();\nListIterator iter2 = \n        list.listIterator();\niter1.next();\niter1.remove();\niter2.next(); \n// throws ConcurrentModificationException\nThe call to iter2.next throws a ConcurrentModificationException since iter2 detects that the list was modified\nexternally. \nTo avoid concurrent modification exceptions, follow this simple rule: You can attach as many iterators to a container\nas you like, provided that all of them are only readers. Alternatively, you can attach a single iterator that can both\nread and write. \nConcurrent modification detection is achieved in a simple way. The container keeps track of the number of mutating\noperations (such as adding and removing elements). Each iterator keeps a separate count of the number of mutating\noperations that it was responsible for. At the beginning of each iterator method, the iterator simply checks whether\nits own mutation count equals that of the container. If not, it throws a ConcurrentModificationException. \nThis is an excellent check and a great improvement over the fundamentally unsafe iterators in the C++ STL\nframework. Note, however, that it does not automatically make collections safe for multithreading. We discuss thread\nsafety issues later in this chapter. \nNOTE: There is, however, a curious exception to the detection of concurrent modifications. The linked list only keeps\ntrack of structural modifications to the list, such as adding and removing links. The set method does not count as a\nstructural modification. You can attach multiple iterators to a linked list, all of which call set to change the contents of\nexisting links. This capability is required for a number of algorithms in the Collections class that we discuss later in this\nchapter. \nNow you have seen the fundamental methods of the LinkedList class. You use a ListIterator to traverse the\nelements of the linked list in either direction and to add and remove elements. \nAs you saw in the preceding section, there are many other useful methods for operating on linked lists that are\ndeclared in the Collection interface. These are, for the most part, implemented in the AbstractCollection superclass of\nthe LinkedList class. For example, the toString method invokes toString on all elements and produces one long string\nof the format [A, B, C]. This is handy for debugging. Use the contains method to check whether an element is present\nin a linked list. For example, the call staff.contains(\"Harry\") returns true if the linked list already contains a string that\nis equal to theString \"Harry\". However, there is no method that returns an iterator to that position. If you want to do\nsomething with the element beyond knowing that it exists, you have to program an iteration loop by hand. \nCAUTION: The Java platform documentation points out that you should not add a reference of a collection to itself.\nOtherwise, it is easy to generate a stack overflow in the JavaTM virtual machine1. For example, the following call is\nfatal: \n \nLinkedList list = new LinkedList();\nlist.add(list); \n// add list to itself\nString contents = list.toString(); \n// dies with infinite recursion\nNaturally, this is not a situation that comes up in everyday programming.\nThe library also supplies a number of methods that are, from a theoretical perspective, somewhat dubious. Linked\nlists do not support fast random access. If you want to see the nth element of a linked list, you have to start at the\nbeginning and skip past the first n - 1 elements first. There is no shortcut. For that reason, programmers don\'t usually\nuse linked lists in programming situations where elements need to be accessed by an integer index. \nNevertheless, the LinkedList class supplies a get method that lets you access a particular element: \nObject obj = list.get(n);\nOf course, this method is not very efficient. If you find yourself using it, you are probably using the wrong data\nstructure for your problem. \nYou should never use this illusory random access method to step through a linked list. The code \nfor (int i = 0; i &lt; list.size(); i++)\n   do something with list.get(i);\n   \nis staggeringly inefficient. Each time you look up another element, the search starts again from the beginning of the\nlist. The LinkedList object makes no effort to cache the position information. \nNOTE: The get method has one slight optimization: if the index is at least size() / 2, then the search for the element\nstarts at the end of the list. \nThe list iterator interface also has a method to tell you the index of the current position. In fact, because Java\niterators conceptually point between elements, it has two of them: the nextIndex method returns the integer index of\nthe element that would be returned by the next call to next; the previousIndex method returns the index of the\nelement that would be returned by the next call to previous. Of course, that is simply one less than nextIndex. These\nmethods are efficient--the iterators keep a count of the current position. Finally, if you have an integer index n, then\nlist.listIterator(n) returns an iterator that points just before the element with index n. That is, calling next yields\nthe same element as list.get(n). Of course, obtaining that iterator is inefficient. \nIf you have a linked list with only a handful of elements, then you don\'t have to be overly paranoid about the cost of\nthe get and set methods. But then why use a linked list in the first place? The only reason to use a linked list is to\nminimize the cost of insertion and removal in the middle of the list. If you only have a few elements, you can just use\nan array or a collection such as ArrayList. \nWe recommend that you simply stay away from all methods that use an integer index to denote a position in a linked\nlist. If you want random access into a collection, use an array or ArrayList, not a linked list. \nThe program in Example 2-1 puts linked lists to work. It simply creates two lists, merges them, then removes every\nsecond element from the second list, and finally tests the removeAll method. We recommend that you trace the\nprogram flow and pay special attention to the iterators. You may find it helpful to draw diagrams of the iterator\npositions, like this: \n|ACE   |BDFG\nA|CE   |BDFG\nAB|CE  B|DFG\n. . .\nNote that the call \nSystem.out.println(a);\nprints all elements in the linked list a. \nExample 2-1: LinkedListTest.java \nimport java.util.*;\npublic class LinkedListTest\n{  public static void main(\n                  String[] args)\n   {  List a = new LinkedList();\n      a.add(\"Angela\");\n      a.add(\"Carl\");\n      a.add(\"Erica\");\n      \n      List b = new LinkedList();\n      b.add(\"Bob\");\n      b.add(\"Doug\");\n      b.add(\"Frances\");\n      b.add(\"Gloria\");\n      \n      // merge the words from b into a\n      \n      ListIterator aIter = a.listIterator();\n      Iterator bIter = b.iterator();\n      \n      while (bIter.hasNext())\n      {  if (aIter.hasNext()) aIter.next();\n         aIter.add(bIter.next());\n      }\n      \n      System.out.println(a);\n      \n      // remove every second \n      //word from b\n      \n      bIter = b.iterator();\n      while (bIter.hasNext())\n      {  bIter.next(); \n      // skip one element\n         if (bIter.hasNext()) \n         {  bIter.next(); \n         // skip next element\n            bIter.remove(); \n            // remove that element\n         }\n      }\n      \n      System.out.println(b);\n      \n      // bulk operation: remove all \n      //words in b from a\n      \n      a.removeAll(b);\n      \n      System.out.println(a);\n      \n   }\n}\n \njava.util.List \n     ListIterator listIterator()\n     returns a list iterator for visiting the elements of the list. \n     ListIterator listIterator(int index)\n     returns a list iterator for visiting the elements of the list whose first call to next will return the element with the\n     given index. Parameters: index the position of the next visited element \n     void add(int i, Object element)\n     adds an element at the specified position. \n     Parameters: index the position of the new element element the element to add \n     void addAll(int i, Collection elements)\n     adds all elements from a collection to the specified position.\n     Parameters: index the position of the first new element\n     elements the elements to add \n     Object remove(int i)\n     removes and returns an element at the specified position.\n     Parameters: index the position of the element to remove \n     Object set(int i, Object element)\n     replaces the element at the specified position with a new element and returns the old element. \n     Parameters: index the replacement position\n     element the new element \n     int indexOf(Object element)\n     returns the position of the first occurrence of an element equal to the specified element, or -1 if no matching\n     element is found. Parameters: element the element to match \njava.util.ListIterator \n     void add(Object element)\n     adds an element before the current position. Parameters: element the element to add \n     void set(Object element)\n     replaces the last element visited by next or previous with a new element. Throws an IllegalStateException if\n     the list structure was modified since the last call to next or previous.\n     Parameters: element the new element \n     boolean hasPrevious()\n     returns true if there is another element to visit when iterating backwards through the list. \n     Object previous()\n     returns the previous object. Throws a NoSuchElementException if the beginning of the list has been reached. \n     int nextIndex()\n     returns the index of the element that would be returned by the next call to next. \n     int previousIndex()\n     returns the index of the element that would be returned by the next call to previous. \njava.util.LinkedList \n     LinkedList()\n     constructs an empty linked list. \n     LinkedList(Collection elements)\n     constructs a linked list and adds all elements from a collection. \n     Parameters: elements the elements to add \n     void addFirst(Object element)\n     void addLast(Object element)\n     add an element to the beginning or the end of the list. \n     Parameters: element the element to add \n     Object getFirst() \n     Object getLast()\n     return the element at the beginning or the end of the list. \n     Object removeFirst() \n     Object removeLast() \nremove and return the element at the beginning or the end of the list. "</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
</section>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="index.html">Overview</a></li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
